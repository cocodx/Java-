事件模型：事件驱动程序，通过监听文件和时间事件来完成相应的功能。
其中文件事件其实就是对socket的抽象，把一个个socket事件抽象成文件事件。
redis基于Reactor模式开发了自己的事件处理器。
当accept，redis、write、close文件事件产生时，文件事件处理器就会回调FD绑定的事件处理器。

用户态到内核态的切换。涉及到上下文的切换，cpu需要保护现场，在进入内核之前要保存寄存器的状态，在内核返回后还需要从寄存器里恢复状态，这是个不小的开销

IO多路复用，epoll，相比select性能更优秀。

就是不停的轮训，socket看看有没有消息发过来。
很消耗性能，用户态到内核态的切换。

IO多路复用就是解决这个问题，select，epoll

select：就是每次把一批socket的fds集合一次性交给内核，由内核自己去遍历fds，判断每个fd的可
读写状态，当fd状态满足时，由用户自己判断去获取。

缺点：不知道哪个socket来数据了，每次都要去遍历一次，那么这个socekt集合数量过大影响效率，select
支持最大1024个并发。

epoll：不用遍历所有的socket，当某个socket消息来的时候，只需要触发对应的socket fd，而不用盲目
的轮询，把监听的socket fd和epoll对象绑定。epoll_wait获取有数据的socket fd，当没有一个socket
有数据的时候，那么此处会阻塞，有数据的话，那么就会返回有数据的fds集合。直接从epoll的就绪队列中
获取有事件的socket，执行接下来的读。整个流程用户程序不用无脑遍历，内核也不用遍历。谁有数据处理
谁。
