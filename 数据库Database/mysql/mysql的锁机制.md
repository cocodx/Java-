共享锁、独占锁  

共享锁，不熟悉，那肯定熟悉java的CAS AomitcInteger  
独占锁，不熟悉，那肯定熟悉java的Synchronized和ReetrantLock  

那么mysql的独占锁，X锁，Exclude独占锁，当一个事务加了独占锁之后，其他事务再更新，都是要加独占锁的。但是只能生成独占锁在后面等待。  
java是sync是怎么运作的，等待这个占有锁线程执行完毕，再去抢占锁，去执行。还是有区别，不会再加锁，没有获取到.  

这时候,有人在更新数据,其他事务可以读取这行数据吗?要加锁吗?  
可以读取,不用加锁,MVCC,默认开启.  根据readview,在undo log版本链条里找一个能读取的版本.  

但是,万一在读取的时候,想要加锁呢?  
Mysql支持一种共享锁,S锁,查询的时候对一行数据加共享锁,语法如下:
```java
select * from table lock in share mode
````
这时候别人就更新不了了，因为啊，共享锁和独占锁是互斥的！  

|锁类型|独占锁|共享锁|
|-|-|-|
|独占锁|互斥|互斥|
|共享锁|互斥|不互斥|

不过一般，查询是不会加共享锁的，很少见。
返回会基于redis/zookeeper的分布式锁来控制业务系统的锁逻辑  

查询的时候，还可以加互斥锁。
```java
select * from table for update
```
这个意思就是说，我查出来，还要更新，此时我加独占锁了，你们就别查了，别更新了！
